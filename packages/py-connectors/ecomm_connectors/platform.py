"""
Internal dropshipping platform connector.

For Developers:
    Connects to the main dropshipping platform's API to fetch products,
    orders, and customers. Used by SaaS services to pull data from a
    user's dropshipping store on our platform.

    Credentials dict must contain:
        - ``api_key``: Platform API key generated by the user.

For QA Engineers:
    This connector calls the platform's public API (``/api/v1/public/``
    endpoints) which is already tested in the platform's own test suite.

For End Users:
    Link your dropshipping platform store automatically when you
    provision a service. Your API key is securely stored and used to
    sync your product catalog and order data.
"""

from __future__ import annotations

from datetime import datetime, timezone
from typing import Any

import httpx

from ecomm_connectors.base import (
    AbstractPlatformConnector,
    ConnectionTestResult,
    ConnectorError,
    NormalizedCustomer,
    NormalizedOrder,
    NormalizedProduct,
)


class PlatformConnector(AbstractPlatformConnector):
    """
    Connector for the internal dropshipping platform.

    For Developers:
        Uses the platform's public API with Bearer token auth.
        The ``store_url`` should point to the platform API base
        (e.g. "http://localhost:8000").

    Args:
        store_url: Platform API base URL.
        credentials: Dict with ``api_key``.
    """

    def __init__(self, store_url: str, credentials: dict[str, str]) -> None:
        super().__init__(store_url, credentials)
        self._api_key = credentials.get("api_key", "")
        if not self._api_key:
            raise ConnectorError(
                "Platform connector requires 'api_key' in credentials",
                platform="platform",
            )

    def _headers(self) -> dict[str, str]:
        """Auth headers for platform API requests."""
        return {
            "Authorization": f"Bearer {self._api_key}",
            "Content-Type": "application/json",
        }

    async def _request(
        self,
        method: str,
        endpoint: str,
        *,
        json: dict | None = None,
        params: dict | None = None,
    ) -> httpx.Response:
        """
        Make an authenticated request to the platform API.

        Args:
            method: HTTP method.
            endpoint: API path (e.g. "/api/v1/public/products").
            json: Optional JSON body.
            params: Optional query parameters.

        Returns:
            httpx.Response on success.

        Raises:
            ConnectorError: On HTTP errors.
        """
        url = f"{self.store_url}{endpoint}"
        async with httpx.AsyncClient(timeout=30.0) as client:
            resp = await client.request(
                method, url, headers=self._headers(), json=json, params=params
            )
            if resp.status_code >= 400:
                raise ConnectorError(
                    f"Platform API error {resp.status_code}: {resp.text[:200]}",
                    status_code=resp.status_code,
                    platform="platform",
                )
            return resp

    @staticmethod
    def _map_product(data: dict[str, Any]) -> NormalizedProduct:
        """
        Map a platform product to NormalizedProduct.

        Args:
            data: Platform product dict.

        Returns:
            NormalizedProduct.
        """
        images = data.get("images", [])
        if isinstance(images, list) and images and isinstance(images[0], dict):
            images = [img.get("url", "") for img in images]

        return NormalizedProduct(
            external_id=str(data.get("id", "")),
            title=data.get("title", data.get("name", "")),
            description=data.get("description", ""),
            price=str(data.get("price", "0.00")),
            currency=data.get("currency", "USD"),
            sku=data.get("sku", ""),
            inventory_quantity=data.get("inventory_quantity", data.get("stock", -1)),
            images=images if isinstance(images, list) else [],
            url=data.get("url", ""),
            vendor=data.get("vendor", ""),
            tags=data.get("tags", []),
            raw=data,
        )

    @staticmethod
    def _map_order(data: dict[str, Any]) -> NormalizedOrder:
        """
        Map a platform order to NormalizedOrder.

        Args:
            data: Platform order dict.

        Returns:
            NormalizedOrder.
        """
        created_at = None
        if data.get("created_at"):
            try:
                ts = data["created_at"]
                if isinstance(ts, str):
                    created_at = datetime.fromisoformat(ts.replace("Z", "+00:00"))
                elif isinstance(ts, (int, float)):
                    created_at = datetime.fromtimestamp(ts, tz=timezone.utc)
            except (ValueError, AttributeError, OSError):
                pass

        return NormalizedOrder(
            external_id=str(data.get("id", "")),
            order_number=str(data.get("order_number", data.get("id", ""))),
            email=data.get("email", data.get("customer_email", "")),
            total=str(data.get("total", data.get("total_price", "0.00"))),
            currency=data.get("currency", "USD"),
            status=data.get("status", ""),
            line_items=data.get("line_items", data.get("items", [])),
            created_at=created_at,
            raw=data,
        )

    @staticmethod
    def _map_customer(data: dict[str, Any]) -> NormalizedCustomer:
        """
        Map a platform customer to NormalizedCustomer.

        Args:
            data: Platform customer dict.

        Returns:
            NormalizedCustomer.
        """
        return NormalizedCustomer(
            external_id=str(data.get("id", "")),
            email=data.get("email", ""),
            first_name=data.get("first_name", data.get("name", "").split(" ")[0]),
            last_name=data.get("last_name", ""),
            total_orders=data.get("total_orders", data.get("orders_count", 0)),
            total_spent=str(data.get("total_spent", "0.00")),
            tags=data.get("tags", []),
            raw=data,
        )

    async def test_connection(self) -> ConnectionTestResult:
        """
        Test the platform connection by calling the health endpoint.

        Returns:
            ConnectionTestResult with platform health status.
        """
        try:
            resp = await self._request("GET", "/api/v1/health")
            health = resp.json()
            return ConnectionTestResult(
                success=True,
                platform="platform",
                store_name=health.get("service", "Dropshipping Platform"),
                message="Connected to platform",
            )
        except ConnectorError as e:
            return ConnectionTestResult(
                success=False,
                platform="platform",
                message=str(e),
            )

    async def fetch_products(
        self, *, limit: int = 50, cursor: str | None = None
    ) -> tuple[list[NormalizedProduct], str | None]:
        """
        Fetch products from the platform's public API.

        Args:
            limit: Products per page.
            cursor: Page number as string.

        Returns:
            Tuple of (products, next_page_str_or_none).
        """
        page = int(cursor) if cursor else 1
        params = {"page": str(page), "page_size": str(limit)}

        resp = await self._request("GET", "/api/v1/public/products", params=params)
        data = resp.json()

        items = data.get("items", data) if isinstance(data, dict) else data
        if not isinstance(items, list):
            items = []
        products = [self._map_product(p) for p in items]

        total = data.get("total", 0) if isinstance(data, dict) else 0
        has_next = (page * limit) < total
        next_cursor = str(page + 1) if has_next else None
        return products, next_cursor

    async def fetch_orders(
        self, *, limit: int = 50, cursor: str | None = None
    ) -> tuple[list[NormalizedOrder], str | None]:
        """
        Fetch orders from the platform's public API.

        Args:
            limit: Orders per page.
            cursor: Page number as string.

        Returns:
            Tuple of (orders, next_page_str_or_none).
        """
        page = int(cursor) if cursor else 1
        params = {"page": str(page), "page_size": str(limit)}

        resp = await self._request("GET", "/api/v1/public/orders", params=params)
        data = resp.json()

        items = data.get("items", data) if isinstance(data, dict) else data
        if not isinstance(items, list):
            items = []
        orders = [self._map_order(o) for o in items]

        total = data.get("total", 0) if isinstance(data, dict) else 0
        has_next = (page * limit) < total
        next_cursor = str(page + 1) if has_next else None
        return orders, next_cursor

    async def fetch_customers(
        self, *, limit: int = 50, cursor: str | None = None
    ) -> tuple[list[NormalizedCustomer], str | None]:
        """
        Fetch customers from the platform's public API.

        Args:
            limit: Customers per page.
            cursor: Page number as string.

        Returns:
            Tuple of (customers, next_page_str_or_none).
        """
        page = int(cursor) if cursor else 1
        params = {"page": str(page), "page_size": str(limit)}

        resp = await self._request("GET", "/api/v1/public/customers", params=params)
        data = resp.json()

        items = data.get("items", data) if isinstance(data, dict) else data
        if not isinstance(items, list):
            items = []
        customers = [self._map_customer(c) for c in items]

        total = data.get("total", 0) if isinstance(data, dict) else 0
        has_next = (page * limit) < total
        next_cursor = str(page + 1) if has_next else None
        return customers, next_cursor

    async def push_product_update(
        self, external_id: str, updates: dict[str, Any]
    ) -> NormalizedProduct:
        """
        Update a product on the platform via API.

        Args:
            external_id: Platform product ID (UUID string).
            updates: Fields to update.

        Returns:
            Updated NormalizedProduct.
        """
        resp = await self._request(
            "PUT", f"/api/v1/public/products/{external_id}", json=updates
        )
        return self._map_product(resp.json())

    async def create_product(self, product_data: dict[str, Any]) -> NormalizedProduct:
        """
        Create a product on the platform via API.

        Args:
            product_data: Product fields.

        Returns:
            Created NormalizedProduct.
        """
        resp = await self._request(
            "POST", "/api/v1/public/products", json=product_data
        )
        return self._map_product(resp.json())
